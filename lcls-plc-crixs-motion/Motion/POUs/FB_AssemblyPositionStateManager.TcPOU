<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.14">
  <POU Name="FB_AssemblyPositionStateManager" Id="{1c44c362-2d86-42b0-87df-a447155dced7}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_AssemblyPositionStateManager
(*
    Handles EPICS moves between multiple states for multiple axes.
    See FB_XXXX for an example.
*)
VAR	
	nAssemblyStates : DINT;
	nAxes :DINT;
	nOutputs :DINT;
	bInit : BOOL := FALSE;
	bAtState : BOOL;
	iAxis : DINT;
	stAxis : DUT_MotionStage;
	stState : DUT_PositionState;
	
	currState : DINT;
	nextState : DINT;
	{attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbXStateManager: FB_PositionStateManager;
	{attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbYStateManager: FB_PositionStateManager;
	{attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbZStateManager: FB_PositionStateManager;
END_VAR
VAR_IN_OUT

	// Array of bMoveEnables to, well, enable based on the assembly state.
    arrOutputs: ARRAY [*, *] OF DUT_PositionState;
	// Array of allowed position state transitions. This is the adjacency matrix
	arrTransitions : ARRAY [*, *] OF BOOL;
	// Array of available states for each axis, e.g. [[x_states], [y_states], [z_states]]
	arrAxisStates : ARRAY [*, *] OF DUT_PositionState;
	// Array of all axes in the assembly
	arrAxes : ARRAY [*] OF DUT_MotionStage;
	// Array of all assembly states
	arrAssemblyStates : ARRAY [*] OF STRING;
END_VAR
VAR_INPUT



END_VAR
VAR_OUTPUT
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bInit THEN
	bInit := TRUE;
	nAssemblyStates := UPPER_BOUND(arrAssemblyStates, 1);
	nAxes := UPPER_BOUND(arrAxes, 1);
	nOutputs := UPPER_BOUND(arrOutputs, 1);
END_IF

// Determine current assembly state
currState := 0; // Start in the unknown state
FOR nextState := 1 TO nOutputs DO // For each defined output state
	bAtState := TRUE;
	FOR iAxis := 1 TO UPPER_BOUND(arrAxes,1) DO // check each axis for a match with the assembly position state
		bAtState := (bAtState AND F_AtPositionState(stMotionStage:=arrAxes[iAxis], stPositionState:=arrOutputs[nextState, iAxis]));
	END_FOR
	IF bAtState THEN
		currState := nextState;
	END_IF
END_FOR

// Reset logic before determining allowed moves
FOR nextState := 1 TO UPPER_BOUND(arrAssemblyStates, 1) DO
	FOR iAxis := 1 TO UPPER_BOUND(arrAxes, 1) DO
		arrOutputs[nextState, iAxis].bMoveOk := FALSE;
	END_FOR
END_FOR

// Update motion logic for next state based on current state
FOR nextState := 1 TO nAssemblyStates DO
	IF arrTransitions[currState, nextState] THEN
		FOR iAxis :=1 TO UPPER_BOUND(arrAxes, 1) DO
			arrOutputs[nextState, iAxis].bMoveOk := TRUE;
		END_FOR
	END_IF
END_FOR
	
// for manager in managers loop?
//fbXStateManager(
//    stMotionStage := stDPX,
//    arrStates := arrStates,
//    setState := enumSet,
//    bEnable := bEnable,
//    bError => bError,
//    nErrorId => nErrorId,
//    sErrorMessage => sErrorMessage,
//    bBusy => bBusy,
//    bDone => bDone,
//    getState => enumGet); ]]></ST>
    </Implementation>
    <LineIds Name="FB_AssemblyPositionStateManager">
      <LineId Id="137" Count="0" />
      <LineId Id="412" Count="2" />
      <LineId Id="287" Count="0" />
      <LineId Id="139" Count="2" />
      <LineId Id="143" Count="0" />
      <LineId Id="411" Count="0" />
      <LineId Id="341" Count="1" />
      <LineId Id="352" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="147" Count="5" />
      <LineId Id="343" Count="0" />
      <LineId Id="346" Count="0" />
      <LineId Id="155" Count="23" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>